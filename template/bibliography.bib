@misc{vello,
	title = {linebender/vello},
	copyright = {Apache-2.0},
	url = {https://github.com/linebender/vello},
	abstract = {A GPU compute-centric 2D renderer.},
	urldate = {2025-01-09},
	publisher = {Linebender},
	month = jan,
	year = {2025},
	note = {original-date: 2020-04-15T15:54:36Z},
}

@misc{wgpu,
	title = {gfx-rs/wgpu},
	copyright = {Apache-2.0},
	url = {https://github.com/gfx-rs/wgpu},
	abstract = {A cross-platform, safe, pure-Rust graphics API.},
	urldate = {2025-01-09},
	publisher = {Rust Graphics Mages},
	month = jan,
	year = {2025},
	note = {original-date: 2018-09-13T19:18:50Z},
	keywords = {d3d12, gpu, hacktoberfest, metal, opengl, rust, vulkan, webgpu},
}

@misc{sanderson_3b1bmanim_2025,
	title = {3b1b/manim},
	copyright = {MIT},
	url = {https://github.com/3b1b/manim},
	abstract = {Animation engine for explanatory math videos},
	urldate = {2025-02-02},
	author = {Sanderson, Grant},
	month = feb,
	year = {2025},
	note = {original-date: 2015-03-22T18:50:58Z},
	keywords = {3b1b-videos, animation, explanatory-math-videos, python},
}

@misc{the_manim_community_developers_manim_2025,
	title = {Manim ‚Äì {Mathematical} {Animation} {Framework}},
	copyright = {MIT},
	url = {https://www.manim.community/},
	abstract = {A community-maintained Python framework for creating mathematical animations.},
	urldate = {2025-02-02},
	author = {{The Manim Community Developers}},
	month = jan,
	year = {2025},
	note = {original-date: 2020-05-19T02:37:13Z},
}

@misc{jkjkil4_jkjkil4janim_2025,
	title = {jkjkil4/{JAnim}},
	copyright = {MIT},
	url = {https://github.com/jkjkil4/JAnim},
	abstract = {A library for creating smooth animations},
	urldate = {2025-02-02},
	author = {jkjkil4},
	month = jan,
	year = {2025},
	note = {original-date: 2022-10-03T00:48:11Z},
	keywords = {animation, janim, python},
}

@misc{webgpu,
	title = {{WebGPU}},
	url = {https://www.w3.org/TR/webgpu/},
	urldate = {2025-01-09},
}

@article{nehab_random-access_2008,
	title = {Random-access rendering of general vector graphics},
	volume = {27},
	issn = {0730-0301},
	/url = {https://dl.acm.org/doi/10.1145/1409060.1409088},
	/doi = {10.1145/1409060.1409088},
	abstract = {We introduce a novel representation for random-access rendering of antialiased vector graphics on the GPU, along with efficient encoding and rendering algorithms. The representation supports a broad class of vector primitives, including multiple layers of semitransparent filled and stroked shapes, with quadratic outlines and color gradients. Our approach is to create a coarse lattice in which each cell contains a variable-length encoding of the graphics primitives it overlaps. These cell-specialized encodings are interpreted at runtime within a pixel shader. Advantages include localized memory access and the ability to map vector graphics onto arbitrary surfaces, or under arbitrary deformations. Most importantly, we perform both prefiltering and supersampling within a single pixel shader invocation, achieving inter-primitive antialiasing at no added memory bandwidth cost. We present an efficient encoding algorithm, and demonstrate high-quality real-time rendering of complex, real-world examples.},
	number = {5},
	urldate = {2025-01-08},
	journal = {ACM Trans. Graph.},
	author = {Nehab, Diego and Hoppe, Hugues},
	month = dec,
	year = {2008},
	keywords = {üìå},
	pages = {135:1--135:10},
	file = {Full Text PDF:C\:\\Users\\xiaob\\Zotero\\storage\\NJN5KIDL\\NehabÂíåHoppe - 2008 - Random-access rendering of general vector graphics.pdf:application/pdf},
}


@article{chickerur_webgl_2024,
	series = {5th {International} {Conference} on {Innovative} {Data} {Communication} {Technologies} and {Application} ({ICIDCA} 2024)},
	title = {{WebGL} vs. {WebGPU}: {A} {Performance} {Analysis} for {Web} 3.0},
	volume = {233},
	issn = {1877-0509},
	shorttitle = {{WebGL} vs. {WebGPU}},
	/url = {https://www.sciencedirect.com/science/article/pii/S1877050924006410},
	/doi = {10.1016/j.procs.2024.03.281},
	abstract = {This study investigates web 3.0 heterogeneous computing with webGL, webGPU, and IPFS. The primary focus is on the benefits of utilising these technologies to enhance the functionality and performance of web 3.0 applications. The study investigates web 3.0 as it currently exists and the constraints that developers face due to graphic, computational, and storage capabilities. According to the findings, incorporating webGL and webGPU can considerably increase user experience, speed, efficacy, and decentralization. Finally, this study summarizes the importance of continuing research in this subject, particularly with relation to platform interoperability and the future prospects of heterogeneous computing on web 3.0 via graphical APIs.},
	urldate = {2025-01-08},
	journal = {Procedia Computer Science},
	author = {Chickerur, Satyadhyan and Balannavar, Sankalp and Hongekar, Pranali and Prerna, Aditi and Jituri, Soumya},
	month = jan,
	year = {2024},
	keywords = {üìå, Performance analysis, Rendering, Web3.0, WebGL, WebGPU},
	pages = {919--928},
	file = {ScienceDirect Snapshot:C\:\\Users\\xiaob\\Zotero\\storage\\KC3D786S\\S1877050924006410.html:text/html},
}


@article{kilgard_gpu-accelerated_2012,
	title = {{GPU}-accelerated path rendering},
	volume = {31},
	issn = {0730-0301, 1557-7368},
	/url = {https://dl.acm.org/doi/10.1145/2366145.2366191},
	d/oi = {10.1145/2366145.2366191},
	abstract = {For thirty years, resolution-independent 2D standards (e.g. PostScript, SVG) have depended on CPU-based algorithms for the Ô¨Ålling and stroking of paths. Advances in graphics hardware have largely ignored accelerating resolution-independent 2D graphics rendered from paths.},
	language = {en},
	number = {6},
	urldate = {2025-01-08},
	journal = {ACM Transactions on Graphics},
	author = {Kilgard, Mark J. and Bolz, Jeff},
	month = nov,
	year = {2012},
	note = {TLDR: This work introduces a two-step "Stencil, then Cover" (StC) programming interface and builds upon existing techniques for curve rendering using the stencil buffer, but explicitly decouple in this programming interface the stenci step to determine a path's filled or stroked coverage from the subsequent cover step to rasterize conservative geometry.},
	pages = {1--10},
	file = {PDF:C\:\\Users\\xiaob\\Zotero\\storage\\3NW9DDL6\\gpupathrender.pdf:application/pdf},
}

@article{dokter_hierarchical_2019,
	title = {Hierarchical {Rasterization} of {Curved} {Primitives} for {Vector} {Graphics} {Rendering} on the {GPU}},
	volume = {38},
	issn = {0167-7055, 1467-8659},
	/url = {https://onlinelibrary.wiley.com/doi/10.1111/cgf.13622},
	/doi = {10.1111/cgf.13622},
	abstract = {In this paper, we introduce the CPatch, a curved primitive that can be used to construct arbitrary vector graphics. A CPatch is a generalization of a 2D polygon: Any number of curves up to a cubic degree bound a primitive. We show that a CPatch can be rasterized efÔ¨Åciently in a hierarchical manner on the GPU, locally discarding irrelevant portions of the curves. Our rasterizer is fast and scalable, works on all patches in parallel, and does not require any approximations. We show a parallel implementation of our rasterizer, which naturally supports all kinds of color spaces, blending and super-sampling. Additionally, we show how vector graphics input can efÔ¨Åciently be converted to a CPatch representation, solving challenges like patch self-intersections and false inside-outside classiÔ¨Åcation. Results indicate that our approach is faster than the state-of-the-art, more Ô¨Çexible and could potentially be implemented in hardware.},
	language = {en},
	number = {2},
	urldate = {2025-01-09},
	journal = {Computer Graphics Forum},
	author = {Dokter, Mark and Hladky, Jozef and Parger, Mathias and Schmalstieg, Dieter and Seidel, Hans‚ÄêPeter and Steinberger, Markus},
	month = may,
	year = {2019},
	note = {TLDR: The CPatch, a curved primitive that can be used to construct arbitrary vector graphics, is introduced and it is shown that a CPatch can be rasterized efficiently in a hierarchical manner on the GPU, locally discarding irrelevant portions of the curves.},
	pages = {93--103},
	file = {PDF:C\:\\Users\\xiaob\\Zotero\\storage\\8FQP5H3X\\Dokter Á≠â - 2019 - Hierarchical Rasterization of Curved Primitives for Vector Graphics Rendering on the GPU.pdf:application/pdf},
}


@article{li_efficient_2016,
	title = {Efficient {GPU} path rendering using scanline rasterization},
	volume = {35},
	issn = {0730-0301},
	/url = {https://dl.acm.org/doi/10.1145/2980179.2982434},
	/doi = {10.1145/2980179.2982434},
	abstract = {We introduce a novel GPU path rendering method based on scan-line rasterization, which is highly work-efficient but traditionally considered as GPU hostile. Our method is parallelized over boundary fragments, i.e., pixels directly intersecting the path boundary. Non-boundary pixels are processed in bulk as horizontal spans like in CPU scanline rasterizers, which saves a significant amount of winding number computation workload. The distinction also allows the majority of our algorithmic steps to focus on boundary fragments only, which leads to highly balanced workload among the GPU threads. In addition, we develop a ray shooting pattern that minimizes the global data dependency when computing winding numbers at anti-aliasing samples. This allows us to shift the majority of winding-number-related workload to the same kernel that consumes its result, which saves a significant amount of GPU memory bandwidth. Experiments show that our method gives a consistent 2.5X speedup over state-of-the-art alternatives for high-quality rendering at Ultra HD resolution, which can increase to more than 30X in extreme cases. We can also get a consistent 10X speedup on animated input.},
	number = {6},
	urldate = {2025-01-09},
	journal = {ACM Trans. Graph.},
	author = {Li, Rui and Hou, Qiming and Zhou, Kun},
	month = dec,
	year = {2016},
	note = {TLDR: A novel GPU path rendering method based on scan-line rasterization, which is highly work-efficient but traditionally considered as GPU hostile, is introduced, which allows the majority of winding-number-related workload to shift to the same kernel that consumes its result, which saves a significant amount of GPU memory bandwidth.},
	pages = {228:1--228:12},
	file = {Full Text PDF:C\:\\Users\\xiaob\\Zotero\\storage\\H26FKTKD\\Li Á≠â - 2016 - Efficient GPU path rendering using scanline rasterization.pdf:application/pdf},
}


@inproceedings{schutz_rendering_2019,
	address = {New York, NY, USA},
	series = {{SA} '19},
	title = {Rendering {Point} {Clouds} with {Compute} {Shaders}},
	isbn = {978-1-4503-6943-5},
	/url = {https://dl.acm.org/doi/10.1145/3355056.3364554},
	/doi = {10.1145/3355056.3364554},
	abstract = {We propose a compute shader based point cloud rasterizer with up to 10 times higher performance than classic point-based rendering with the GL\_POINT primitive. In addition to that, our rasterizer offers 5 byte depth-buffer precision with uniform or customizable distribution, and we show that it is possible to implement a high-quality splatting method that blends together overlapping fragments while still maintaining higher frame-rates than the traditional approach.},
	urldate = {2025-01-09},
	booktitle = {{SIGGRAPH} {Asia} 2019 {Posters}},
	publisher = {Association for Computing Machinery},
	author = {Schutz, Markus and Wimmer, Michael},
	month = nov,
	year = {2019},
	note = {TLDR: A compute shader based point cloud rasterizer with up to 10 times higher performance than classic point-based rendering with the GL\_POINT primitive, and it is shown that it is possible to implement a high-quality splatting method that blends together overlapping fragments while still maintaining higher frame-rates than the traditional approach.},
	pages = {1--2},
	file = {Full Text PDF:C\:\\Users\\xiaob\\Zotero\\storage\\JLSWRI8D\\SchutzÂíåWimmer - 2019 - Rendering Point Clouds with Compute Shaders.pdf:application/pdf},
}


@article{park_shader-based_2021,
	title = {A {Shader}-{Based} {Ray} {Tracing} {Engine}},
	volume = {11},
	copyright = {http://creativecommons.org/licenses/by/3.0/},
	issn = {2076-3417},
	/url = {https://www.mdpi.com/2076-3417/11/7/3264},
	/doi = {10.3390/app11073264},
	abstract = {Recently, ray tracing techniques have been highly adopted to produce high quality images and animations. In this paper, we present our design and implementation of a real-time ray-traced rendering engine. We achieved real-time capability for triangle primitives, based on the ray tracing techniques on GPGPU (general-purpose graphics processing unit) compute shaders. To accelerate the ray tracing engine, we used a set of acceleration techniques, including bounding volume hierarchy, its roped representation, joint up-sampling, and bilateral filtering. Our current implementation shows remarkable speed-ups, with acceptable error values. Experimental results shows 2.5‚Äì13.6 times acceleration, and less than 3\% error values for the 95\% confidence range. Our next step will be enhancing bilateral filter behaviors.},
	language = {en},
	number = {7},
	urldate = {2025-01-09},
	journal = {Applied Sciences},
	author = {Park, Sukjun and Baek, Nakhoon},
	month = jan,
	year = {2021},
	note = {Number: 7
Publisher: Multidisciplinary Digital Publishing Institute
TLDR: The design and implementation of a real-time ray-traced rendering engine, based on the ray tracing techniques on GPGPU (general-purpose graphics processing unit) compute shaders, and its roped representation and bilateral filtering are presented.},
	keywords = {acceleration, bilateral up-sampling, ray tracing},
	pages = {3264},
	file = {Full Text PDF:C\:\\Users\\xiaob\\Zotero\\storage\\4NUG8DCY\\ParkÂíåBaek - 2021 - A Shader-Based Ray Tracing Engine.pdf:application/pdf},
}


@article{eberly_triangulation_nodate,
	title = {Triangulation by {Ear} {Clipping}},
	language = {en},
	author = {Eberly, David},
	file = {PDF:/Users/azurice/Zotero/storage/SIAMRUTD/Eberly - Triangulation by Ear Clipping.pdf:application/pdf},
}


@article{livesu_deterministic_2022,
	title = {Deterministic {Linear} {Time} {Constrained} {Triangulation} {Using} {Simplified} {Earcut}},
	volume = {28},
	issn = {1941-0506},
	url = {https://ieeexplore.ieee.org/abstract/document/9392369},
	doi = {10.1109/TVCG.2021.3070046},
	abstract = {Triangulation algorithms that conform to a set of non-intersecting input segments typically proceed in an incremental fashion, by inserting points first, and then segments. Inserting a segment amounts to: (1) deleting all the triangles it intersects; (2) filling the so generated hole with two polygons that have the wanted segment as shared edge; (3) triangulate each polygon separately. In this article we prove that these polygons are such that all their convex vertices but two can be used to form triangles in an earcut fashion, without the need to check whether other polygon points are located within each ear. The fact that any simple polygon contains at least three convex vertices guarantees the existence of a valid ear to cut, ensuring convergence. Not only this translates to an optimal deterministic linear time triangulation algorithm, but such algorithm is also trivial to implement. We formally prove the correctness of our approach, also validating it in practical applications and comparing it with prior art.},
	number = {12},
	urldate = {2025-02-16},
	journal = {IEEE Transactions on Visualization and Computer Graphics},
	author = {Livesu, Marco and Cherchi, Gianmarco and Scateni, Riccardo and Attene, Marco},
	month = dec,
	year = {2022},
	note = {Conference Name: IEEE Transactions on Visualization and Computer Graphics},
	keywords = {CDT, Complexity theory, Constrained triangulation, Convergence, earcut, Encoding, segment insertion, tessellation, Testing, Time complexity},
	pages = {5172--5177},
	file = {Full Text PDF:/Users/azurice/Zotero/storage/VCPXEMVN/Livesu Á≠â - 2022 - Deterministic Linear Time Constrained Triangulation Using Simplified Earcut.pdf:application/pdf;IEEE Xplore Abstract Record:/Users/azurice/Zotero/storage/GTIIS9DR/9392369.html:text/html},
}


@article{gustavson_anti-aliased_2011,
	title = {Anti-aliased {Euclidean} distance transform},
	volume = {32},
	copyright = {https://www.elsevier.com/tdm/userlicense/1.0/},
	issn = {01678655},
	url = {https://linkinghub.elsevier.com/retrieve/pii/S0167865510002953},
	doi = {10.1016/j.patrec.2010.08.010},
	abstract = {We present a modiÔ¨Åed distance measure for use with distance transforms of anti-aliased, area sampled grayscale images of arbitrary binary contours. The modiÔ¨Åed measure can be used in any vector-propagation Euclidean distance transform. Our test implementation in the traditional SSED8 algorithm shows a considerable improvement in accuracy and homogeneity of the distance Ô¨Åeld compared to a traditional binary image transform. At the expense of a 10 slowdown for a particular image resolution, we achieve an accuracy comparable to a binary transform on a supersampled image with 16 16 higher resolution, which would require 256 times more computations and memory.},
	language = {en},
	number = {2},
	urldate = {2025-02-15},
	journal = {Pattern Recognition Letters},
	author = {Gustavson, Stefan and Strand, Robin},
	month = jan,
	year = {2011},
	note = {TLDR: A modified distance measure is presented for use with distance transforms of anti-aliased, area sampled grayscale images of arbitrary binary contours and achieves an accuracy comparable to a binary transform on a supersampled image with 16x16 higher resolution, which would require 256 times more computations and memory.},
	pages = {252--257},
	file = {PDF:/Users/azurice/Zotero/storage/U7QTTP5D/GustavsonÂíåStrand - 2011 - Anti-aliased Euclidean distance transform.pdf:application/pdf},
}


@inproceedings{green_improved_2007,
	address = {New York, NY, USA},
	series = {{SIGGRAPH} '07},
	title = {Improved alpha-tested magnification for vector textures and special effects},
	isbn = {978-1-4503-1823-5},
	url = {https://dl.acm.org/doi/10.1145/1281500.1281665},
	doi = {10.1145/1281500.1281665},
	abstract = {A simple and efficient method is presented which allows improved rendering of glyphs composed of curved and linear elements. A distance field is generated from a high resolution image, and then stored into a channel of a lower-resolution texture. In the simplest case, this texture can then be rendered simply by using the alpha-testing and alpha-thresholding feature of modern GPUs, without a custom shader. This allows the technique to be used on even the lowest-end 3D graphics hardware.With the use of programmable shading, the technique is extended to perform various special effect renderings, including soft edges, outlining, drop shadows, multi-colored images, and sharp corners.},
	urldate = {2025-02-15},
	booktitle = {{ACM} {SIGGRAPH} 2007 courses},
	publisher = {Association for Computing Machinery},
	author = {Green, Chris},
	month = aug,
	year = {2007},
	pages = {9--18},
	file = {Full Text PDF:/Users/azurice/Zotero/storage/LJ9LYVE8/Green - 2007 - Improved alpha-tested magnification for vector textures and special effects.pdf:application/pdf},
}



@inproceedings{loop_resolution_2005,
	address = {New York, NY, USA},
	series = {{SIGGRAPH} '05},
	title = {Resolution independent curve rendering using programmable graphics hardware},
	isbn = {978-1-4503-7825-3},
	url = {https://dl.acm.org/doi/10.1145/1186822.1073303},
	doi = {10.1145/1186822.1073303},
	abstract = {We present a method for resolution independent rendering of paths and bounded regions, defined by quadratic and cubic spline curves, that leverages the parallelism of programmable graphics hardware to achieve high performance. A simple implicit equation for a parametric curve is found in a space that can be thought of as an analog to texture space. The image of a curve's B√©zier control points are found in this space and assigned to the control points as texture coordinates. When the triangle(s) corresponding to the B√©zier curve control hull are rendered, a pixel shader program evaluates the implicit equation for a pixel's interpolated texture coordinates to determine an inside/outside test for the curve. We extend our technique to handle anti-aliasing of boundaries. We also construct a vector image from mosaics of triangulated B√©zier control points and show how to deform such images to create resolution independent texture on three dimensional objects.},
	urldate = {2025-01-09},
	booktitle = {{ACM} {SIGGRAPH} 2005 {Papers}},
	publisher = {Association for Computing Machinery},
	author = {Loop, Charles and Blinn, Jim},
	month = jul,
	year = {2005},
	note = {TLDR: A method for resolution independent rendering of paths and bounded regions, defined by quadratic and cubic spline curves, that leverages the parallelism of programmable graphics hardware to achieve high performance is presented.},
	pages = {1000--1009},
	file = {Full Text PDF:C\:\\Users\\xiaob\\Zotero\\storage\\S5VL2FAS\\LoopÂíåBlinn - 2005 - Resolution independent curve rendering using programmable graphics hardware.pdf:application/pdf},
}
